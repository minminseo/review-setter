// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: box.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBox = `-- name: CreateBox :exec
INSERT INTO 
    review_boxes (
        id,
        user_id,
        category_id,
        pattern_id,
        name,
        registered_at,
        edited_at
    ) VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7
    )
`

type CreateBoxParams struct {
	ID           pgtype.UUID        `json:"id"`
	UserID       pgtype.UUID        `json:"user_id"`
	CategoryID   pgtype.UUID        `json:"category_id"`
	PatternID    pgtype.UUID        `json:"pattern_id"`
	Name         string             `json:"name"`
	RegisteredAt pgtype.Timestamptz `json:"registered_at"`
	EditedAt     pgtype.Timestamptz `json:"edited_at"`
}

func (q *Queries) CreateBox(ctx context.Context, arg CreateBoxParams) error {
	_, err := q.db.Exec(ctx, createBox,
		arg.ID,
		arg.UserID,
		arg.CategoryID,
		arg.PatternID,
		arg.Name,
		arg.RegisteredAt,
		arg.EditedAt,
	)
	return err
}

const deleteBox = `-- name: DeleteBox :exec
DELETE FROM
    review_boxes
WHERE
    id = $1 AND user_id = $2
`

type DeleteBoxParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteBox(ctx context.Context, arg DeleteBoxParams) error {
	_, err := q.db.Exec(ctx, deleteBox, arg.ID, arg.UserID)
	return err
}

const getAllBoxesByCategoryID = `-- name: GetAllBoxesByCategoryID :many
SELECT
    id,
    user_id,
    category_id,
    pattern_id,
    name,
    registered_at,
    edited_at
FROM
    review_boxes
WHERE
    category_id = $1 AND user_id = $2
ORDER BY
    registered_at
`

type GetAllBoxesByCategoryIDParams struct {
	CategoryID pgtype.UUID `json:"category_id"`
	UserID     pgtype.UUID `json:"user_id"`
}

type GetAllBoxesByCategoryIDRow struct {
	ID           pgtype.UUID        `json:"id"`
	UserID       pgtype.UUID        `json:"user_id"`
	CategoryID   pgtype.UUID        `json:"category_id"`
	PatternID    pgtype.UUID        `json:"pattern_id"`
	Name         string             `json:"name"`
	RegisteredAt pgtype.Timestamptz `json:"registered_at"`
	EditedAt     pgtype.Timestamptz `json:"edited_at"`
}

func (q *Queries) GetAllBoxesByCategoryID(ctx context.Context, arg GetAllBoxesByCategoryIDParams) ([]GetAllBoxesByCategoryIDRow, error) {
	rows, err := q.db.Query(ctx, getAllBoxesByCategoryID, arg.CategoryID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllBoxesByCategoryIDRow{}
	for rows.Next() {
		var i GetAllBoxesByCategoryIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.PatternID,
			&i.Name,
			&i.RegisteredAt,
			&i.EditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBoxByID = `-- name: GetBoxByID :one
SELECT
    id,
    user_id,
    category_id,
    pattern_id,
    name,
    registered_at,
    edited_at
FROM
    review_boxes
WHERE
    id = $1 AND category_id = $2 AND user_id = $3
`

type GetBoxByIDParams struct {
	ID         pgtype.UUID `json:"id"`
	CategoryID pgtype.UUID `json:"category_id"`
	UserID     pgtype.UUID `json:"user_id"`
}

type GetBoxByIDRow struct {
	ID           pgtype.UUID        `json:"id"`
	UserID       pgtype.UUID        `json:"user_id"`
	CategoryID   pgtype.UUID        `json:"category_id"`
	PatternID    pgtype.UUID        `json:"pattern_id"`
	Name         string             `json:"name"`
	RegisteredAt pgtype.Timestamptz `json:"registered_at"`
	EditedAt     pgtype.Timestamptz `json:"edited_at"`
}

func (q *Queries) GetBoxByID(ctx context.Context, arg GetBoxByIDParams) (GetBoxByIDRow, error) {
	row := q.db.QueryRow(ctx, getBoxByID, arg.ID, arg.CategoryID, arg.UserID)
	var i GetBoxByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CategoryID,
		&i.PatternID,
		&i.Name,
		&i.RegisteredAt,
		&i.EditedAt,
	)
	return i, err
}

const updateBox = `-- name: UpdateBox :exec
UPDATE
    review_boxes
SET
    name = $1,
    edited_at = $2
WHERE
    id = $3 AND category_id = $4 AND user_id = $5
`

type UpdateBoxParams struct {
	Name       string             `json:"name"`
	EditedAt   pgtype.Timestamptz `json:"edited_at"`
	ID         pgtype.UUID        `json:"id"`
	CategoryID pgtype.UUID        `json:"category_id"`
	UserID     pgtype.UUID        `json:"user_id"`
}

func (q *Queries) UpdateBox(ctx context.Context, arg UpdateBoxParams) error {
	_, err := q.db.Exec(ctx, updateBox,
		arg.Name,
		arg.EditedAt,
		arg.ID,
		arg.CategoryID,
		arg.UserID,
	)
	return err
}

const updateBoxIfNoReviewItems = `-- name: UpdateBoxIfNoReviewItems :execrows
UPDATE
    review_boxes
SET
    pattern_id = $1,
    name       = $2,
    edited_at  = $3
WHERE
    review_boxes.id = $4
AND
    review_boxes.category_id = $5
AND
    review_boxes.user_id = $6
AND NOT EXISTS (
            SELECT 
                1
            FROM 
                review_items
            WHERE 
                review_items.box_id  = $7
            AND 
                review_items.user_id = $6
            )
`

type UpdateBoxIfNoReviewItemsParams struct {
	PatternID  pgtype.UUID        `json:"pattern_id"`
	Name       string             `json:"name"`
	EditedAt   pgtype.Timestamptz `json:"edited_at"`
	ID         pgtype.UUID        `json:"id"`
	CategoryID pgtype.UUID        `json:"category_id"`
	UserID     pgtype.UUID        `json:"user_id"`
	BoxID      pgtype.UUID        `json:"box_id"`
}

func (q *Queries) UpdateBoxIfNoReviewItems(ctx context.Context, arg UpdateBoxIfNoReviewItemsParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateBoxIfNoReviewItems,
		arg.PatternID,
		arg.Name,
		arg.EditedAt,
		arg.ID,
		arg.CategoryID,
		arg.UserID,
		arg.BoxID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
