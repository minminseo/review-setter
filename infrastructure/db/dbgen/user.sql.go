// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :exec
INSERT INTO 
    users (
        id,
        email_search_key,
        email,
        password,
        timezone,
        theme_color,
        language
    ) VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7
    )
`

type CreateUserParams struct {
	ID             pgtype.UUID    `json:"id"`
	EmailSearchKey string         `json:"email_search_key"`
	Email          string         `json:"email"`
	Password       string         `json:"password"`
	Timezone       string         `json:"timezone"`
	ThemeColor     ThemeColorEnum `json:"theme_color"`
	Language       string         `json:"language"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser,
		arg.ID,
		arg.EmailSearchKey,
		arg.Email,
		arg.Password,
		arg.Timezone,
		arg.ThemeColor,
		arg.Language,
	)
	return err
}

const findUserByEmailSearchKey = `-- name: FindUserByEmailSearchKey :one
SELECT
    id,
    email,
    password,
    theme_color,
    language,
    verified_at
FROM
    users
WHERE
    email_search_key = $1
`

type FindUserByEmailSearchKeyRow struct {
	ID         pgtype.UUID        `json:"id"`
	Email      string             `json:"email"`
	Password   string             `json:"password"`
	ThemeColor ThemeColorEnum     `json:"theme_color"`
	Language   string             `json:"language"`
	VerifiedAt pgtype.Timestamptz `json:"verified_at"`
}

func (q *Queries) FindUserByEmailSearchKey(ctx context.Context, emailSearchKey string) (FindUserByEmailSearchKeyRow, error) {
	row := q.db.QueryRow(ctx, findUserByEmailSearchKey, emailSearchKey)
	var i FindUserByEmailSearchKeyRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.ThemeColor,
		&i.Language,
		&i.VerifiedAt,
	)
	return i, err
}

const getUserSettingByID = `-- name: GetUserSettingByID :one
SELECT
    email,
    timezone,
    theme_color,
    language
FROM
    users
WHERE
    id = $1
`

type GetUserSettingByIDRow struct {
	Email      string         `json:"email"`
	Timezone   string         `json:"timezone"`
	ThemeColor ThemeColorEnum `json:"theme_color"`
	Language   string         `json:"language"`
}

func (q *Queries) GetUserSettingByID(ctx context.Context, id pgtype.UUID) (GetUserSettingByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserSettingByID, id)
	var i GetUserSettingByIDRow
	err := row.Scan(
		&i.Email,
		&i.Timezone,
		&i.ThemeColor,
		&i.Language,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE
    users
SET
    email_search_key = $1,
    email = $2,
    timezone = $3,
    theme_color = $4,
    language = $5
WHERE
    id = $6
`

type UpdateUserParams struct {
	EmailSearchKey string         `json:"email_search_key"`
	Email          string         `json:"email"`
	Timezone       string         `json:"timezone"`
	ThemeColor     ThemeColorEnum `json:"theme_color"`
	Language       string         `json:"language"`
	ID             pgtype.UUID    `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.EmailSearchKey,
		arg.Email,
		arg.Timezone,
		arg.ThemeColor,
		arg.Language,
		arg.ID,
	)
	return err
}

// #nosec G101
const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE
    users
SET
    password = $1
WHERE
    id = $2
`

type UpdateUserPasswordParams struct {
	Password string      `json:"password"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.Password, arg.ID)
	return err
}

const updateVerifiedAt = `-- name: UpdateVerifiedAt :exec
UPDATE
    users
SET
    verified_at = $1
WHERE
    id = $2
`

type UpdateVerifiedAtParams struct {
	VerifiedAt pgtype.Timestamptz `json:"verified_at"`
	ID         pgtype.UUID        `json:"id"`
}

func (q *Queries) UpdateVerifiedAt(ctx context.Context, arg UpdateVerifiedAtParams) error {
	_, err := q.db.Exec(ctx, updateVerifiedAt, arg.VerifiedAt, arg.ID)
	return err
}
