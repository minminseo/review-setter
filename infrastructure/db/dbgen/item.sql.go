// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: item.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAllDailyReviewDates = `-- name: CountAllDailyReviewDates :one
SELECT
    COUNT(*) AS count
FROM
    review_dates
WHERE
    user_id = $1
AND
    scheduled_date = $2
`

type CountAllDailyReviewDatesParams struct {
	UserID     pgtype.UUID `json:"user_id"`
	TargetDate pgtype.Date `json:"target_date"`
}

// 今日の全復習日数を取得
func (q *Queries) CountAllDailyReviewDates(ctx context.Context, arg CountAllDailyReviewDatesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAllDailyReviewDates, arg.UserID, arg.TargetDate)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDailyDatesGroupedByBoxByUserID = `-- name: CountDailyDatesGroupedByBoxByUserID :many
SELECT
    category_id,
    box_id,
    COUNT(*) AS count
FROM
    review_dates
WHERE
    user_id = $1
AND
    scheduled_date = $2
AND
    is_completed = false
AND
    box_id IS NOT NULL
GROUP BY
    category_id,
    box_id
`

type CountDailyDatesGroupedByBoxByUserIDParams struct {
	UserID     pgtype.UUID `json:"user_id"`
	TargetDate pgtype.Date `json:"target_date"`
}

type CountDailyDatesGroupedByBoxByUserIDRow struct {
	CategoryID pgtype.UUID `json:"category_id"`
	BoxID      pgtype.UUID `json:"box_id"`
	Count      int64       `json:"count"`
}

func (q *Queries) CountDailyDatesGroupedByBoxByUserID(ctx context.Context, arg CountDailyDatesGroupedByBoxByUserIDParams) ([]CountDailyDatesGroupedByBoxByUserIDRow, error) {
	rows, err := q.db.Query(ctx, countDailyDatesGroupedByBoxByUserID, arg.UserID, arg.TargetDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountDailyDatesGroupedByBoxByUserIDRow{}
	for rows.Next() {
		var i CountDailyDatesGroupedByBoxByUserIDRow
		if err := rows.Scan(&i.CategoryID, &i.BoxID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countDailyDatesUnclassifiedByUserID = `-- name: CountDailyDatesUnclassifiedByUserID :many
SELECT
    COUNT(*) AS count
FROM
    review_dates
WHERE
    user_id = $1
AND
    scheduled_date = $2
AND
    is_completed = false
AND
    box_id IS NULL
`

type CountDailyDatesUnclassifiedByUserIDParams struct {
	UserID     pgtype.UUID `json:"user_id"`
	TargetDate pgtype.Date `json:"target_date"`
}

func (q *Queries) CountDailyDatesUnclassifiedByUserID(ctx context.Context, arg CountDailyDatesUnclassifiedByUserIDParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, countDailyDatesUnclassifiedByUserID, arg.UserID, arg.TargetDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var count int64
		if err := rows.Scan(&count); err != nil {
			return nil, err
		}
		items = append(items, count)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countDailyDatesUnclassifiedGroupedByCategoryByUserID = `-- name: CountDailyDatesUnclassifiedGroupedByCategoryByUserID :many
SELECT
    category_id,
    COUNT(*) AS count
FROM
    review_dates
WHERE
    user_id = $1
AND
    scheduled_date = $2
AND
    is_completed = false
AND
    box_id IS NULL
GROUP BY
    category_id
`

type CountDailyDatesUnclassifiedGroupedByCategoryByUserIDParams struct {
	UserID     pgtype.UUID `json:"user_id"`
	TargetDate pgtype.Date `json:"target_date"`
}

type CountDailyDatesUnclassifiedGroupedByCategoryByUserIDRow struct {
	CategoryID pgtype.UUID `json:"category_id"`
	Count      int64       `json:"count"`
}

func (q *Queries) CountDailyDatesUnclassifiedGroupedByCategoryByUserID(ctx context.Context, arg CountDailyDatesUnclassifiedGroupedByCategoryByUserIDParams) ([]CountDailyDatesUnclassifiedGroupedByCategoryByUserIDRow, error) {
	rows, err := q.db.Query(ctx, countDailyDatesUnclassifiedGroupedByCategoryByUserID, arg.UserID, arg.TargetDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountDailyDatesUnclassifiedGroupedByCategoryByUserIDRow{}
	for rows.Next() {
		var i CountDailyDatesUnclassifiedGroupedByCategoryByUserIDRow
		if err := rows.Scan(&i.CategoryID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countItemsGroupedByBoxByUserID = `-- name: CountItemsGroupedByBoxByUserID :many

SELECT
    category_id,
    box_id,
    COUNT(*) AS count
FROM
    review_items
WHERE
    user_id = $1
AND
    is_Finished = false
GROUP BY
    category_id,
    box_id
`

type CountItemsGroupedByBoxByUserIDRow struct {
	CategoryID pgtype.UUID `json:"category_id"`
	BoxID      pgtype.UUID `json:"box_id"`
	Count      int64       `json:"count"`
}

// ここから下は概要表示用の取得クエリ
func (q *Queries) CountItemsGroupedByBoxByUserID(ctx context.Context, userID pgtype.UUID) ([]CountItemsGroupedByBoxByUserIDRow, error) {
	rows, err := q.db.Query(ctx, countItemsGroupedByBoxByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountItemsGroupedByBoxByUserIDRow{}
	for rows.Next() {
		var i CountItemsGroupedByBoxByUserIDRow
		if err := rows.Scan(&i.CategoryID, &i.BoxID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countUnclassifiedItemsByUserID = `-- name: CountUnclassifiedItemsByUserID :many
SELECT
    COUNT(*) AS count
FROM
    review_items
WHERE
    user_id = $1
AND
    is_Finished = false
AND
    box_id IS NULL
`

func (q *Queries) CountUnclassifiedItemsByUserID(ctx context.Context, userID pgtype.UUID) ([]int64, error) {
	rows, err := q.db.Query(ctx, countUnclassifiedItemsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var count int64
		if err := rows.Scan(&count); err != nil {
			return nil, err
		}
		items = append(items, count)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countUnclassifiedItemsGroupedByCategoryByUserID = `-- name: CountUnclassifiedItemsGroupedByCategoryByUserID :many
SELECT
    category_id,
    COUNT(*) AS count
FROM
    review_items
WHERE
    user_id = $1
AND
    is_Finished = false
AND
    box_id IS NULL
GROUP BY
    category_id
`

type CountUnclassifiedItemsGroupedByCategoryByUserIDRow struct {
	CategoryID pgtype.UUID `json:"category_id"`
	Count      int64       `json:"count"`
}

func (q *Queries) CountUnclassifiedItemsGroupedByCategoryByUserID(ctx context.Context, userID pgtype.UUID) ([]CountUnclassifiedItemsGroupedByCategoryByUserIDRow, error) {
	rows, err := q.db.Query(ctx, countUnclassifiedItemsGroupedByCategoryByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountUnclassifiedItemsGroupedByCategoryByUserIDRow{}
	for rows.Next() {
		var i CountUnclassifiedItemsGroupedByCategoryByUserIDRow
		if err := rows.Scan(&i.CategoryID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createItem = `-- name: CreateItem :exec
INSERT INTO
    review_items (
        id,
        user_id,
        category_id,
        box_id,
        pattern_id,
        name,
        detail,
        learned_date,
        is_Finished,
        registered_at,
        edited_at
    )
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11
    )
`

type CreateItemParams struct {
	ID           pgtype.UUID        `json:"id"`
	UserID       pgtype.UUID        `json:"user_id"`
	CategoryID   pgtype.UUID        `json:"category_id"`
	BoxID        pgtype.UUID        `json:"box_id"`
	PatternID    pgtype.UUID        `json:"pattern_id"`
	Name         string             `json:"name"`
	Detail       pgtype.Text        `json:"detail"`
	LearnedDate  pgtype.Date        `json:"learned_date"`
	IsFinished   bool               `json:"is_finished"`
	RegisteredAt pgtype.Timestamptz `json:"registered_at"`
	EditedAt     pgtype.Timestamptz `json:"edited_at"`
}

func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) error {
	_, err := q.db.Exec(ctx, createItem,
		arg.ID,
		arg.UserID,
		arg.CategoryID,
		arg.BoxID,
		arg.PatternID,
		arg.Name,
		arg.Detail,
		arg.LearnedDate,
		arg.IsFinished,
		arg.RegisteredAt,
		arg.EditedAt,
	)
	return err
}

type CreateReviewDatesParams struct {
	ID                   pgtype.UUID `json:"id"`
	UserID               pgtype.UUID `json:"user_id"`
	CategoryID           pgtype.UUID `json:"category_id"`
	BoxID                pgtype.UUID `json:"box_id"`
	ItemID               pgtype.UUID `json:"item_id"`
	StepNumber           int16       `json:"step_number"`
	InitialScheduledDate pgtype.Date `json:"initial_scheduled_date"`
	ScheduledDate        pgtype.Date `json:"scheduled_date"`
	IsCompleted          bool        `json:"is_completed"`
}

const deleteItem = `-- name: DeleteItem :exec
DELETE
FROM
    review_items
WHERE
    id = $1
AND
    user_id = $2
`

type DeleteItemParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteItem(ctx context.Context, arg DeleteItemParams) error {
	_, err := q.db.Exec(ctx, deleteItem, arg.ID, arg.UserID)
	return err
}

const deleteReviewDates = `-- name: DeleteReviewDates :exec
DELETE
FROM
    review_dates
WHERE
    item_id = $1
AND
    user_id = $2
`

type DeleteReviewDatesParams struct {
	ItemID pgtype.UUID `json:"item_id"`
	UserID pgtype.UUID `json:"user_id"`
}

// 復習日のパターンIDがnilに変更されたとき
func (q *Queries) DeleteReviewDates(ctx context.Context, arg DeleteReviewDatesParams) error {
	_, err := q.db.Exec(ctx, deleteReviewDates, arg.ItemID, arg.UserID)
	return err
}

const getAllDailyReviewDates = `-- name: GetAllDailyReviewDates :many
SELECT
    rd.id,
    rd.category_id,
    rd.box_id,
    rd.step_number,
    rd.prev_scheduled_date,
    rd.scheduled_date,
    rd.next_scheduled_date,
    rd.is_completed,
    ri.name,
    ri.detail,
    ri.registered_at,
    ri.edited_at
FROM (
    SELECT
        id,
        category_id,
        box_id,
        item_id,
        step_number,
        scheduled_date,
        is_completed,
        CAST(
            LAG(scheduled_date) OVER (
        PARTITION BY item_id
        ORDER BY step_number
        ) AS date
        ) AS prev_scheduled_date,
        CAST(
            LEAD(scheduled_date) OVER (
        PARTITION BY item_id
        ORDER BY step_number
        ) AS date
        ) AS next_scheduled_date
    FROM
        review_dates
    WHERE
        user_id = $1::uuid
) AS rd
JOIN
    review_items AS ri
ON
    ri.id = rd.item_id
WHERE
    rd.scheduled_date = $2::date
ORDER BY
    rd.category_id    NULLS LAST,
    rd.box_id         NULLS LAST,
    ri.registered_at
`

type GetAllDailyReviewDatesParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Today  pgtype.Date `json:"today"`
}

type GetAllDailyReviewDatesRow struct {
	ID                pgtype.UUID        `json:"id"`
	CategoryID        pgtype.UUID        `json:"category_id"`
	BoxID             pgtype.UUID        `json:"box_id"`
	StepNumber        int16              `json:"step_number"`
	PrevScheduledDate pgtype.Date        `json:"prev_scheduled_date"`
	ScheduledDate     pgtype.Date        `json:"scheduled_date"`
	NextScheduledDate pgtype.Date        `json:"next_scheduled_date"`
	IsCompleted       bool               `json:"is_completed"`
	Name              string             `json:"name"`
	Detail            pgtype.Text        `json:"detail"`
	RegisteredAt      pgtype.Timestamptz `json:"registered_at"`
	EditedAt          pgtype.Timestamptz `json:"edited_at"`
}

// LAG→item_idごとにstep_numberの昇順で並べた時、scheduled_dateが持つstep_numberより一個前のstep_numberのscheduled_dateを取得
// LEAD→item_idごとにstep_numberの昇順で並べた時、scheduled_dateが持つstep_numberより一個後のstep_numberのscheduled_dateを取得
// 今日の復習日を取得するクエリ
func (q *Queries) GetAllDailyReviewDates(ctx context.Context, arg GetAllDailyReviewDatesParams) ([]GetAllDailyReviewDatesRow, error) {
	rows, err := q.db.Query(ctx, getAllDailyReviewDates, arg.UserID, arg.Today)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllDailyReviewDatesRow{}
	for rows.Next() {
		var i GetAllDailyReviewDatesRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.BoxID,
			&i.StepNumber,
			&i.PrevScheduledDate,
			&i.ScheduledDate,
			&i.NextScheduledDate,
			&i.IsCompleted,
			&i.Name,
			&i.Detail,
			&i.RegisteredAt,
			&i.EditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllReviewDatesByBoxID = `-- name: GetAllReviewDatesByBoxID :many
SELECT
    id,
    user_id,
    category_id,
    box_id,
    item_id,
    step_number,
    initial_scheduled_date,
    scheduled_date,
    is_completed
FROM
    review_dates
WHERE
    box_id = $1
AND    
    user_id = $2
ORDER BY
    item_id,
    step_number
`

type GetAllReviewDatesByBoxIDParams struct {
	BoxID  pgtype.UUID `json:"box_id"`
	UserID pgtype.UUID `json:"user_id"`
}

type GetAllReviewDatesByBoxIDRow struct {
	ID                   pgtype.UUID `json:"id"`
	UserID               pgtype.UUID `json:"user_id"`
	CategoryID           pgtype.UUID `json:"category_id"`
	BoxID                pgtype.UUID `json:"box_id"`
	ItemID               pgtype.UUID `json:"item_id"`
	StepNumber           int16       `json:"step_number"`
	InitialScheduledDate pgtype.Date `json:"initial_scheduled_date"`
	ScheduledDate        pgtype.Date `json:"scheduled_date"`
	IsCompleted          bool        `json:"is_completed"`
}

// 　ボックス内画面用の全復習物一覧取得機能（復習日（子）のみ一覧取得（親は区別しない。親が未完了復習物かどうかも区別しない））。
func (q *Queries) GetAllReviewDatesByBoxID(ctx context.Context, arg GetAllReviewDatesByBoxIDParams) ([]GetAllReviewDatesByBoxIDRow, error) {
	rows, err := q.db.Query(ctx, getAllReviewDatesByBoxID, arg.BoxID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllReviewDatesByBoxIDRow{}
	for rows.Next() {
		var i GetAllReviewDatesByBoxIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.BoxID,
			&i.ItemID,
			&i.StepNumber,
			&i.InitialScheduledDate,
			&i.ScheduledDate,
			&i.IsCompleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUnFinishedItemsByBoxID = `-- name: GetAllUnFinishedItemsByBoxID :many
SELECT
    id,
    user_id,
    category_id,
    box_id,
    pattern_id,
    name,
    detail,
    learned_date,
    is_Finished,
    registered_at,
    edited_at
FROM
    review_items
WHERE
    box_id = $1
AND
    user_id = $2
ORDER BY
    registered_at
`

type GetAllUnFinishedItemsByBoxIDParams struct {
	BoxID  pgtype.UUID `json:"box_id"`
	UserID pgtype.UUID `json:"user_id"`
}

type GetAllUnFinishedItemsByBoxIDRow struct {
	ID           pgtype.UUID        `json:"id"`
	UserID       pgtype.UUID        `json:"user_id"`
	CategoryID   pgtype.UUID        `json:"category_id"`
	BoxID        pgtype.UUID        `json:"box_id"`
	PatternID    pgtype.UUID        `json:"pattern_id"`
	Name         string             `json:"name"`
	Detail       pgtype.Text        `json:"detail"`
	LearnedDate  pgtype.Date        `json:"learned_date"`
	IsFinished   bool               `json:"is_finished"`
	RegisteredAt pgtype.Timestamptz `json:"registered_at"`
	EditedAt     pgtype.Timestamptz `json:"edited_at"`
}

// ボックス内画面用の未完了の全復習物一覧取得機能（復習物（親）のみ一覧取得）
func (q *Queries) GetAllUnFinishedItemsByBoxID(ctx context.Context, arg GetAllUnFinishedItemsByBoxIDParams) ([]GetAllUnFinishedItemsByBoxIDRow, error) {
	rows, err := q.db.Query(ctx, getAllUnFinishedItemsByBoxID, arg.BoxID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllUnFinishedItemsByBoxIDRow{}
	for rows.Next() {
		var i GetAllUnFinishedItemsByBoxIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.BoxID,
			&i.PatternID,
			&i.Name,
			&i.Detail,
			&i.LearnedDate,
			&i.IsFinished,
			&i.RegisteredAt,
			&i.EditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUnFinishedUnclassifiedItemsByCategoryID = `-- name: GetAllUnFinishedUnclassifiedItemsByCategoryID :many
SELECT
    id,
    user_id,
    category_id,
    box_id,
    pattern_id,
    name,
    detail,
    learned_date,
    is_Finished,
    registered_at,
    edited_at
FROM
    review_items
WHERE
    category_id = $1
AND
    user_id = $2
AND
    box_id IS NULL
AND
    is_Finished = false
ORDER BY
    registered_at
`

type GetAllUnFinishedUnclassifiedItemsByCategoryIDParams struct {
	CategoryID pgtype.UUID `json:"category_id"`
	UserID     pgtype.UUID `json:"user_id"`
}

type GetAllUnFinishedUnclassifiedItemsByCategoryIDRow struct {
	ID           pgtype.UUID        `json:"id"`
	UserID       pgtype.UUID        `json:"user_id"`
	CategoryID   pgtype.UUID        `json:"category_id"`
	BoxID        pgtype.UUID        `json:"box_id"`
	PatternID    pgtype.UUID        `json:"pattern_id"`
	Name         string             `json:"name"`
	Detail       pgtype.Text        `json:"detail"`
	LearnedDate  pgtype.Date        `json:"learned_date"`
	IsFinished   bool               `json:"is_finished"`
	RegisteredAt pgtype.Timestamptz `json:"registered_at"`
	EditedAt     pgtype.Timestamptz `json:"edited_at"`
}

func (q *Queries) GetAllUnFinishedUnclassifiedItemsByCategoryID(ctx context.Context, arg GetAllUnFinishedUnclassifiedItemsByCategoryIDParams) ([]GetAllUnFinishedUnclassifiedItemsByCategoryIDRow, error) {
	rows, err := q.db.Query(ctx, getAllUnFinishedUnclassifiedItemsByCategoryID, arg.CategoryID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllUnFinishedUnclassifiedItemsByCategoryIDRow{}
	for rows.Next() {
		var i GetAllUnFinishedUnclassifiedItemsByCategoryIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.BoxID,
			&i.PatternID,
			&i.Name,
			&i.Detail,
			&i.LearnedDate,
			&i.IsFinished,
			&i.RegisteredAt,
			&i.EditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUnFinishedUnclassifiedItemsByUserID = `-- name: GetAllUnFinishedUnclassifiedItemsByUserID :many
SELECT
    id,
    user_id,
    category_id,
    box_id,
    pattern_id,
    name,
    detail,
    learned_date,
    is_Finished,
    registered_at,
    edited_at
FROM
    review_items
WHERE
    user_id = $1
AND
    category_id IS NULL
AND
    box_id IS NULL
AND
    is_Finished = false
ORDER BY
    registered_at
`

type GetAllUnFinishedUnclassifiedItemsByUserIDRow struct {
	ID           pgtype.UUID        `json:"id"`
	UserID       pgtype.UUID        `json:"user_id"`
	CategoryID   pgtype.UUID        `json:"category_id"`
	BoxID        pgtype.UUID        `json:"box_id"`
	PatternID    pgtype.UUID        `json:"pattern_id"`
	Name         string             `json:"name"`
	Detail       pgtype.Text        `json:"detail"`
	LearnedDate  pgtype.Date        `json:"learned_date"`
	IsFinished   bool               `json:"is_finished"`
	RegisteredAt pgtype.Timestamptz `json:"registered_at"`
	EditedAt     pgtype.Timestamptz `json:"edited_at"`
}

// ホーム画面の未分類未完了復習物
func (q *Queries) GetAllUnFinishedUnclassifiedItemsByUserID(ctx context.Context, userID pgtype.UUID) ([]GetAllUnFinishedUnclassifiedItemsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getAllUnFinishedUnclassifiedItemsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllUnFinishedUnclassifiedItemsByUserIDRow{}
	for rows.Next() {
		var i GetAllUnFinishedUnclassifiedItemsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.BoxID,
			&i.PatternID,
			&i.Name,
			&i.Detail,
			&i.LearnedDate,
			&i.IsFinished,
			&i.RegisteredAt,
			&i.EditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUnclassifiedReviewDatesByCategoryID = `-- name: GetAllUnclassifiedReviewDatesByCategoryID :many
SELECT
    id,
    user_id,
    category_id,
    box_id,
    item_id,
    step_number,
    initial_scheduled_date,
    scheduled_date,
    is_completed
FROM
    review_dates
WHERE
    category_id = $1
AND
    user_id = $2
AND
    box_id IS NULL
ORDER BY
    item_id,
    step_number
`

type GetAllUnclassifiedReviewDatesByCategoryIDParams struct {
	CategoryID pgtype.UUID `json:"category_id"`
	UserID     pgtype.UUID `json:"user_id"`
}

type GetAllUnclassifiedReviewDatesByCategoryIDRow struct {
	ID                   pgtype.UUID `json:"id"`
	UserID               pgtype.UUID `json:"user_id"`
	CategoryID           pgtype.UUID `json:"category_id"`
	BoxID                pgtype.UUID `json:"box_id"`
	ItemID               pgtype.UUID `json:"item_id"`
	StepNumber           int16       `json:"step_number"`
	InitialScheduledDate pgtype.Date `json:"initial_scheduled_date"`
	ScheduledDate        pgtype.Date `json:"scheduled_date"`
	IsCompleted          bool        `json:"is_completed"`
}

func (q *Queries) GetAllUnclassifiedReviewDatesByCategoryID(ctx context.Context, arg GetAllUnclassifiedReviewDatesByCategoryIDParams) ([]GetAllUnclassifiedReviewDatesByCategoryIDRow, error) {
	rows, err := q.db.Query(ctx, getAllUnclassifiedReviewDatesByCategoryID, arg.CategoryID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllUnclassifiedReviewDatesByCategoryIDRow{}
	for rows.Next() {
		var i GetAllUnclassifiedReviewDatesByCategoryIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.BoxID,
			&i.ItemID,
			&i.StepNumber,
			&i.InitialScheduledDate,
			&i.ScheduledDate,
			&i.IsCompleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUnclassifiedReviewDatesByUserID = `-- name: GetAllUnclassifiedReviewDatesByUserID :many
SELECT
    id,
    user_id,
    category_id,
    box_id,
    item_id,
    step_number,
    initial_scheduled_date,
    scheduled_date,
    is_completed
FROM
    review_dates
WHERE
    user_id = $1
AND
    category_id IS NULL
AND
    box_id IS NULL
ORDER BY
    item_id,
    step_number
`

type GetAllUnclassifiedReviewDatesByUserIDRow struct {
	ID                   pgtype.UUID `json:"id"`
	UserID               pgtype.UUID `json:"user_id"`
	CategoryID           pgtype.UUID `json:"category_id"`
	BoxID                pgtype.UUID `json:"box_id"`
	ItemID               pgtype.UUID `json:"item_id"`
	StepNumber           int16       `json:"step_number"`
	InitialScheduledDate pgtype.Date `json:"initial_scheduled_date"`
	ScheduledDate        pgtype.Date `json:"scheduled_date"`
	IsCompleted          bool        `json:"is_completed"`
}

func (q *Queries) GetAllUnclassifiedReviewDatesByUserID(ctx context.Context, userID pgtype.UUID) ([]GetAllUnclassifiedReviewDatesByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getAllUnclassifiedReviewDatesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllUnclassifiedReviewDatesByUserIDRow{}
	for rows.Next() {
		var i GetAllUnclassifiedReviewDatesByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.BoxID,
			&i.ItemID,
			&i.StepNumber,
			&i.InitialScheduledDate,
			&i.ScheduledDate,
			&i.IsCompleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEditedAtByItemID = `-- name: GetEditedAtByItemID :one
SELECT
    edited_at
FROM
    review_items
WHERE
    id = $1
AND
    user_id = $2
`

type GetEditedAtByItemIDParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

// EditedAt取得専用
func (q *Queries) GetEditedAtByItemID(ctx context.Context, arg GetEditedAtByItemIDParams) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getEditedAtByItemID, arg.ID, arg.UserID)
	var edited_at pgtype.Timestamptz
	err := row.Scan(&edited_at)
	return edited_at, err
}

const getItemByID = `-- name: GetItemByID :one
SELECT
    id,
    user_id,
    category_id,
    box_id,
    pattern_id,
    name,
    detail,
    learned_date,
    is_Finished,
    registered_at,
    edited_at
FROM
    review_items
WHERE
    id = $1
AND
    user_id = $2
`

type GetItemByIDParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

type GetItemByIDRow struct {
	ID           pgtype.UUID        `json:"id"`
	UserID       pgtype.UUID        `json:"user_id"`
	CategoryID   pgtype.UUID        `json:"category_id"`
	BoxID        pgtype.UUID        `json:"box_id"`
	PatternID    pgtype.UUID        `json:"pattern_id"`
	Name         string             `json:"name"`
	Detail       pgtype.Text        `json:"detail"`
	LearnedDate  pgtype.Date        `json:"learned_date"`
	IsFinished   bool               `json:"is_finished"`
	RegisteredAt pgtype.Timestamptz `json:"registered_at"`
	EditedAt     pgtype.Timestamptz `json:"edited_at"`
}

// 学習日変更など、どういうリクエストなのかを判定するために使う
func (q *Queries) GetItemByID(ctx context.Context, arg GetItemByIDParams) (GetItemByIDRow, error) {
	row := q.db.QueryRow(ctx, getItemByID, arg.ID, arg.UserID)
	var i GetItemByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CategoryID,
		&i.BoxID,
		&i.PatternID,
		&i.Name,
		&i.Detail,
		&i.LearnedDate,
		&i.IsFinished,
		&i.RegisteredAt,
		&i.EditedAt,
	)
	return i, err
}

const getReviewDateIDsByItemID = `-- name: GetReviewDateIDsByItemID :many
SELECT
    id
FROM
    review_dates
WHERE
    item_id = $1
AND
    user_id = $2
ORDER BY
    step_number
`

type GetReviewDateIDsByItemIDParams struct {
	ItemID pgtype.UUID `json:"item_id"`
	UserID pgtype.UUID `json:"user_id"`
}

// 復習日Upate処理用。ReviewDateIDを使い回すために使う
func (q *Queries) GetReviewDateIDsByItemID(ctx context.Context, arg GetReviewDateIDsByItemIDParams) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getReviewDateIDsByItemID, arg.ItemID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.UUID{}
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewDatesByItemID = `-- name: GetReviewDatesByItemID :many
SELECT
    id,
    user_id,
    category_id,
    box_id,
    item_id,
    step_number,
    initial_scheduled_date,
    scheduled_date,
    is_completed
FROM
    review_dates
WHERE
    item_id = $1
AND
    user_id = $2
ORDER BY
    step_number
`

type GetReviewDatesByItemIDParams struct {
	ItemID pgtype.UUID `json:"item_id"`
	UserID pgtype.UUID `json:"user_id"`
}

type GetReviewDatesByItemIDRow struct {
	ID                   pgtype.UUID `json:"id"`
	UserID               pgtype.UUID `json:"user_id"`
	CategoryID           pgtype.UUID `json:"category_id"`
	BoxID                pgtype.UUID `json:"box_id"`
	ItemID               pgtype.UUID `json:"item_id"`
	StepNumber           int16       `json:"step_number"`
	InitialScheduledDate pgtype.Date `json:"initial_scheduled_date"`
	ScheduledDate        pgtype.Date `json:"scheduled_date"`
	IsCompleted          bool        `json:"is_completed"`
}

func (q *Queries) GetReviewDatesByItemID(ctx context.Context, arg GetReviewDatesByItemIDParams) ([]GetReviewDatesByItemIDRow, error) {
	rows, err := q.db.Query(ctx, getReviewDatesByItemID, arg.ItemID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReviewDatesByItemIDRow{}
	for rows.Next() {
		var i GetReviewDatesByItemIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.BoxID,
			&i.ItemID,
			&i.StepNumber,
			&i.InitialScheduledDate,
			&i.ScheduledDate,
			&i.IsCompleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasCompletedReviewDateByItemID = `-- name: HasCompletedReviewDateByItemID :one
SELECT EXISTS (
    SELECT
        1
    FROM
        review_dates
    WHERE
        item_id = $1
    AND
        user_id = $2
    AND
        is_completed = TRUE)
`

type HasCompletedReviewDateByItemIDParams struct {
	ItemID pgtype.UUID `json:"item_id"`
	UserID pgtype.UUID `json:"user_id"`
}

// 完了済みの復習日がないか判別するためのクエリ
func (q *Queries) HasCompletedReviewDateByItemID(ctx context.Context, arg HasCompletedReviewDateByItemIDParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasCompletedReviewDateByItemID, arg.ItemID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isPatternRelatedToItemByPatternID = `-- name: IsPatternRelatedToItemByPatternID :one
SELECT EXISTS (
    SELECT
        1
    FROM
        review_items
    WHERE
        pattern_id = $1
    AND
        user_id = $2
)
`

type IsPatternRelatedToItemByPatternIDParams struct {
	PatternID pgtype.UUID `json:"pattern_id"`
	UserID    pgtype.UUID `json:"user_id"`
}

// patternパッケージで使う
func (q *Queries) IsPatternRelatedToItemByPatternID(ctx context.Context, arg IsPatternRelatedToItemByPatternIDParams) (bool, error) {
	row := q.db.QueryRow(ctx, isPatternRelatedToItemByPatternID, arg.PatternID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateItem = `-- name: UpdateItem :exec
UPDATE
    review_items
SET
    category_id = $1,
    box_id = $2,
    pattern_id = $3,
    name = $4,
    detail = $5,
    learned_date = $6,
    is_Finished = $7,
    edited_at = $8
WHERE
    id = $9
AND
    user_id = $10
`

type UpdateItemParams struct {
	CategoryID  pgtype.UUID        `json:"category_id"`
	BoxID       pgtype.UUID        `json:"box_id"`
	PatternID   pgtype.UUID        `json:"pattern_id"`
	Name        string             `json:"name"`
	Detail      pgtype.Text        `json:"detail"`
	LearnedDate pgtype.Date        `json:"learned_date"`
	IsFinished  bool               `json:"is_finished"`
	EditedAt    pgtype.Timestamptz `json:"edited_at"`
	ID          pgtype.UUID        `json:"id"`
	UserID      pgtype.UUID        `json:"user_id"`
}

// 移動、完了、学習日変更、その他編集に使う
func (q *Queries) UpdateItem(ctx context.Context, arg UpdateItemParams) error {
	_, err := q.db.Exec(ctx, updateItem,
		arg.CategoryID,
		arg.BoxID,
		arg.PatternID,
		arg.Name,
		arg.Detail,
		arg.LearnedDate,
		arg.IsFinished,
		arg.EditedAt,
		arg.ID,
		arg.UserID,
	)
	return err
}

const updateItemAsFinished = `-- name: UpdateItemAsFinished :exec
UPDATE
    review_items
SET
    is_Finished = true,
    edited_at = $1
WHERE
    id = $2
AND
    user_id = $3
`

type UpdateItemAsFinishedParams struct {
	EditedAt pgtype.Timestamptz `json:"edited_at"`
	ID       pgtype.UUID        `json:"id"`
	UserID   pgtype.UUID        `json:"user_id"`
}

func (q *Queries) UpdateItemAsFinished(ctx context.Context, arg UpdateItemAsFinishedParams) error {
	_, err := q.db.Exec(ctx, updateItemAsFinished, arg.EditedAt, arg.ID, arg.UserID)
	return err
}

const updateItemAsUnfinished = `-- name: UpdateItemAsUnfinished :exec
UPDATE
    review_items
SET
    is_Finished = false,
    edited_at = $1
WHERE
    id = $2
AND
    user_id = $3
`

type UpdateItemAsUnfinishedParams struct {
	EditedAt pgtype.Timestamptz `json:"edited_at"`
	ID       pgtype.UUID        `json:"id"`
	UserID   pgtype.UUID        `json:"user_id"`
}

func (q *Queries) UpdateItemAsUnfinished(ctx context.Context, arg UpdateItemAsUnfinishedParams) error {
	_, err := q.db.Exec(ctx, updateItemAsUnfinished, arg.EditedAt, arg.ID, arg.UserID)
	return err
}

const updateReviewDateAsCompleted = `-- name: UpdateReviewDateAsCompleted :exec
UPDATE
    review_dates
SET
    is_completed = true
WHERE
    id = $1
AND
    user_id = $2
`

type UpdateReviewDateAsCompletedParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) UpdateReviewDateAsCompleted(ctx context.Context, arg UpdateReviewDateAsCompletedParams) error {
	_, err := q.db.Exec(ctx, updateReviewDateAsCompleted, arg.ID, arg.UserID)
	return err
}

const updateReviewDateAsInCompleted = `-- name: UpdateReviewDateAsInCompleted :exec
UPDATE
    review_dates
SET
    is_completed = false
WHERE
    id = $1
AND
    user_id = $2
`

type UpdateReviewDateAsInCompletedParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) UpdateReviewDateAsInCompleted(ctx context.Context, arg UpdateReviewDateAsInCompletedParams) error {
	_, err := q.db.Exec(ctx, updateReviewDateAsInCompleted, arg.ID, arg.UserID)
	return err
}

const updateReviewDates = `-- name: UpdateReviewDates :exec
UPDATE review_dates r
SET
    scheduled_date = v.scheduled_date,
    is_completed = v.is_completed
FROM
    UNNEST(
        $2::reviewdate_input[]
    ) AS v(id, scheduled_date, is_completed)
WHERE
    r.id = v.id
AND
    r.user_id = ($1)::uuid
`

type UpdateReviewDatesParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Input  []string    `json:"input"`
}

// 復習日手動変更、完了、学習日変更機能の副次的な変更に使う
func (q *Queries) UpdateReviewDates(ctx context.Context, arg UpdateReviewDatesParams) error {
	_, err := q.db.Exec(ctx, updateReviewDates, arg.UserID, arg.Input)
	return err
}
